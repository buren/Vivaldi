{"name":"Vivaldi","tagline":"Interpreted language inspired by Python, Ruby, Lisp, and so forth","body":"# Vivaldi #\r\n\r\nVivaldi is a simple interpreted language inspired by Ruby, Python, Lisp, etc,\r\nsupporting duck-typing, object orientation, and some functional constructs.\r\n\r\n## Overview ##\r\n\r\n### Basics ###\r\n\r\nVivaldi can be run either from a file or from the REPL:\r\n\r\n    $ cat test.vv\r\n    puts(\"Hello, world!\")\r\n    $ vivaldi ./test.vv\r\n    Hello, world!\r\n    $ ./vivaldi\r\n    >>> puts(\"Hello, REPL!\")\r\n    Hello, REPL!\r\n    => nil\r\n    >>> quit()\r\n    $\r\n\r\nVivaldi expressions are separated by newlines or semicolons.\r\nComments in Vivaldi are C-style `// till end of line` comments&mdash; multiline\r\ncomments aren't supported yet. For a full description of the grammar in\r\nBackus-Naur form, see grammar.txt.\r\n\r\n### Compiling\r\n\r\nVivaldi's been tested on 64-bit OS X 10.10.2, and 32-bit Arch Linux with Linux\r\n3.18, both with Clang/libc++ 3.5 and Boost 1.57.0. libc++ is required, and,\r\nunfortunately, since Boost binaries are used, so is a Boost compiled with\r\nlibc++. The codebase (or should be!) is fully conforming C++14--- it's quite\r\neasy to add support for libstdc++, since it would basically consist of ripping\r\nout a bunch of C++14 features, but I'm not really inclined to do that unless\r\nthere's a particularly pressing need.\r\n\r\n### Builtins ###\r\n\r\nVivaldi has a fairly limited set of builtin types:\r\n\r\n#### Objects ####\r\n\r\nThe root of the inheritance tree; every type in Vivaldi inherits from Object\r\n(which in turn inherits from... itself; it really is turtles all the way down!)\r\nObjects support a few universal methods:\r\n\r\n* `type()` &mdash; Returns the type of `self`.\r\n* `not()` &mdash;  Returns whether or not `self` is truthy (i.e. not `false` or\r\n  `nil`).\r\n* `equals(x)`, `unequal(x)` &mdash; Returns true if `self` has the same object\r\nID as `x`, and `false` otherwise (vice versa for `unequal`). These methods\r\nshould be overridden by any classes with value-based concepts of semantics (for\r\ninstance, in the standard library, `String`, `Symbol`, `Integer`, and so forth\r\nall override them).\r\n\r\n#### Nil ####\r\n`nil` &mdash; like `nil` in Ruby and Lisp, or `None` in Python.\r\n\r\n#### Bools ####\r\n`true` and `false`. What'd you expect?\r\n\r\n#### Floats ####\r\n64-bit floating-point values.\r\n\r\n#### Integers ####\r\n32-bit signed integers. Integer literals can be written in decimal, hexadecimal,\r\noctal, or binary:\r\n\r\n    let eighteen = 18\r\n    eighteen == 0x12\r\n    eighteen == 022\r\n    eighteen == 0b10010\r\n\r\n#### Strings ####\r\nSimple, mutable string class. Currently supports:\r\n\r\n* `init(x)`&mdash; if `x` is a String or a Symbol, copies its string value;\r\n  otherwise, creates a String with `x`'s display value. For instance, `new\r\n  String(12)` will return `\"12\"`.\r\n* `size()`&mdash; returns the size of the string.\r\n* `append(x)`&mdash; Appends the String `x` to `self`.\r\n* `add(x)`&mdash; Returns a string formed form concatenating `self` and the String\r\n  `x`, leaving `self` unchanged.\r\n* `times(x)`&mdash; Returns a string formed by concatenating `x` copies of `self`,\r\n  leaving `self` unchanged.\r\n* `equals(x)`, `unequal(x)`&mdash; Returns `true` if `x` is a String equal in value\r\n  to `self`, and `false` otherwise (vice versa for `unequal`).\r\n\r\n#### Symbols ####\r\n`'symbol_name` - as in Ruby or Lisp:\r\n\r\n* `init(x)`&mdash; Creates a new Symbol with the string value of `x`, where `x` is a\r\n  String or a Symbol.\r\n* `equals(x)`, `unequal(x)`&mdash; Returns `true` if `x` is a Symbol equal in value\r\n  to `self`, and `false` otherwise (vice versa for `unequal`).\r\n\r\n#### Arrays ####\r\nSimple mutable array type:\r\n\r\n    let array = [1, 2, 3]\r\n    let three = array.size()\r\n    array.append('foo)\r\n    let four = array.size()\r\n    let two = array[1]\r\n    array[2] = \"foo\"\r\n    array // [1, 2, \"foo\"]\r\n\r\n* `init(x)`&mdash; Returns a copy of the Array `x`.\r\n* `size()`&mdash; Returns the size of `self`.\r\n* `append(x)`&mdash; Pushes the value `x` onto the end of `self`.\r\n* `at(x)`&mdash; Returns the value at index `x`.\r\n* `set_at(x, y)`&mdash; Sets the value at index `x` to `y`, returning `y`.\r\n* `start()`&mdash; Returns an iterator pointing to the beginning of `self`.\r\n* `end()`&mdash; Returns an iterator pointing to the end of `self`.\r\n* `add(x)`&mdash; Returns the concatenation of `self` and Array `x`, leaving `self`\r\n  unchanged.\r\n\r\n#### Dictionaries ####\r\nMutable hash-map type. At the moment, there's no way to override a type's\r\nequality or hash methods, so you're stuck with whatever you're inheriting\r\nfrom&mdash; which is based on object ID if you derive from Object:\r\n\r\n    let dict = { 'foo: 5, \"bar\": 6 }\r\n    let two = dict.size()\r\n    dict[0.5] = 'baz\r\n    let three = dict.size()\r\n    let five = dict['foo]\r\n    dict // { 0.500000: 'baz, 'foo: 5, \"bar\": 6 }\r\n\r\n* `init(x)`&mdash; Returns a copy of the Dictionary `x`.\r\n* `size()`&mdash; Returns the size of `self`.\r\n* `at(x)`&mdash; Returns the value at key `x`; if no such value exists, inserts (and\r\n  returns) `nil` at `x`.\r\n* `set_at(x, y)`&mdash; Sets the value at key `x` to `y`, returning `y`.\r\n\r\n#### Ranges ####\r\nProvides a range over any pair of objects that can be\r\n\r\n* Compared with `>` (`greater`)\r\n* Incremented by adding 1 (via `add`)\r\n\r\nA range covers [start, end):\r\n\r\n    >>> for i in 1 to 5: puts(i) // \"<x> to <y>\" is sugar for \"new Range(x, y)\"\r\n    1\r\n    2\r\n    3\r\n    4\r\n    => nil\r\n\r\n* `init(x, y)`&mdash; Returns a Range from `x` to `y`. If they're not comparable or\r\n  incrementable, this won't blow up *immediately*&mdash; only when you first try to\r\n  use it.\r\n* `start()`&mdash; Just returns `self`; see the section on Iterators to understand\r\n  why.\r\n* `size()`&mdash; Returns `y - x`. Don't call this if subtraction won't work!\r\n* `at_end()`&mdash; Returns if `x == y` (well, actually, if `!(y > x)`, so a Range\r\n  from `1.3` to `5.0` doesn't go on infinitely).\r\n* `increment`&mdash; Add 1 to `x`\r\n* `to_arr`&mdash; Creates an Array from all values from `x` to `y`.\r\n\r\n#### Functions ####\r\nFunctions! Syntactically, a function is very simple:\r\n\r\n    fn <name>(<arguments>): <body>\r\n\r\nA function body is any valid Vivaldi expression (which is to say any valid\r\nVivaldi code):\r\n\r\n    fn is_three(x): x == 3\r\n\r\nA lambda is identical to a function, just without the name&mdash; or, more\r\naccurately, a function is just a lambda with a name. The following:\r\n\r\n    let five_returner = fn(): 5\r\n\r\nis completely identical to\r\n\r\n    fn five_returner(): 5\r\n\r\nOnce defined, functions work more or less like in Python:\r\n\r\n    fn id(x): x\r\n\r\n    let function = id\r\n    function(1) // 1\r\n\r\nIn functions and methods, `self` works a little differently than in Python or\r\nRuby. It's not explicitly passed as an argument, but rather is implicitly passed\r\nwhenever called as a member of an object. The following is perfectly valid:\r\n\r\n    fn not_method(): return self.a\r\n    not_method() // throws exception\r\n\r\n    let myobj = new Object()\r\n    myobj.a = 5\r\n    myobj.yes_method = not_method\r\n    myobj.yes_method() // returns 5\r\n\r\n`return` can be used to exit out of a function early, but it's unnecessary for\r\nthe last expression of a function body (or *only* expression, unless it's\r\nwrapped in a block):\r\n\r\n    // contrived; this could just be 'fn is_even(x): x % 2 == 0'\r\n    fn is_even(x): do\r\n      if x % 2 == 0: return true\r\n      false\r\n    end\r\n\r\n#### Types ####\r\nEverything in Vivaldi is an object, and has\r\n\r\n* Members:\r\n\r\n        // a is an object\r\n        a.foo = 5\r\n        let five = a.foo\r\n\r\n* Methods (actually just members that happen to be functions):\r\n\r\n        // a is an object\r\n        a.foo = 5\r\n        a.bar = fn(): self.foo\r\n        let five = a.bar()\r\n\r\n* A type:\r\n\r\n        let int_type = int.type()\r\n        int_type == Integer\r\n\r\nDefining custom types is simple:\r\n\r\n    class MyType\r\n      fn init(x): self.x = x\r\n      fn x_is_equal_to(y): self.x = y\r\n    end\r\n\r\n    let my_obj = new MyType(5)\r\n    let yes = my_obj.x_is_equal_to(5)\r\n    let no = my_obj.x_is_equal_to(47)\r\n\r\n* `parent()`&mdash; Returns the parent type of `self`.\r\n\r\n#### Iterators and Ranges ####\r\n\r\nIterators are the basic way to, well, iterate over something. A basic iterator\r\ntype supports three methods:\r\n\r\n* `get()` &mdash; returns the item currently pointed to\r\n* `increment` &mdash; moves the iterator to the next item in its range, and returns\r\n  itself.\r\n* `at_end()` &mdash; returns whether or not the iterator is at the end of its range.\r\n  If it is, the iterator doesn't point to anything valid&mdash; conceptually, it\r\n  works like this:\r\n\r\n        { item 0, item 2 ... item n - 1, item n }\r\n          ^                                     ^\r\n          start                                 end\r\n\r\nA range is even simpler; it only needs to support one method, `start()`, that\r\nreturns an iterator pointing to its first element. In the standard library, both\r\n`Array` and `String` are ranges, and `ArrayIterator` and `String` are their\r\ncorresponding iterators. `Range` is both a range (natch!) and an iterator&mdash;\r\ncalling `start()` on a range just returns itself.\r\n\r\nIterators are used to implement for loops:\r\n\r\n    for i in range: puts(i)\r\n\r\nis equivalent to something like:\r\n\r\n    let <implicit_var> = range.start()\r\n    while !<implicit_var>.at_end(): do\r\n      let i = <implicit_var>.get()\r\n      puts(i)\r\n      <implicit_var>.increment()\r\n    end\r\n\r\n### Structures ###\r\n\r\nVivaldi expressions comprise:\r\n\r\n#### Literals ####\r\n`5`, `5.0`, `true`, `nil`, `\"string\"`, `'symbol`, `['array]`, and so forth.\r\n\r\n#### Variables, Declarations and Assignments ####\r\n\r\nAll variables must be declared before use:\r\n\r\n    i = 5     // wrong &mdash; i hasn't been declared yet\r\n    let i = 5 // right\r\n    i = 3     // right &mdash; i has been declared, so assigning to it is OK\r\n\r\n#### Control Flow ####\r\n\r\nVivaldi's basic control flow structures are cond statements, while loops, and\r\nfor loops:\r\n\r\n    let i = cond false: \"not me!\",\r\n                 true:  \"me!\"\r\n    while true: puts(\"looping endlessly...\")\r\n\r\nCond statements work as in Lisp: the first member of each pair is evaluated\r\nuntil one is truthy (i.e. not `false` or `nil`). When the truthy member is\r\nfound, the second half of that pair is evaluated and returned. If no truthy\r\ntests are found, the statement returns `nil`.\r\n\r\nThe keyword `if` is provided as a synonym to `cond`, since it reads more\r\nnaturally for one-body cond statements:\r\n\r\n    // i is a variable\r\n    let a = if i: \"i is truthy\"\r\n    if a == nil: puts(\"i isn't truthy\")\r\n\r\n    // equivalent:\r\n    let a = cond i: \"i is truthy\"\r\n    cond a == nil: puts(\"i isn't truthy\")\r\n\r\nwhile loops are very straightforward:\r\n\r\n    while <condition>: <expression>\r\n\r\nFor loops are familiar to anyone who's ever used Python or Ruby:\r\n\r\n    for <i> in <range>: <expression>\r\n\r\nFor more on for loops, see iterators.\r\n\r\nNote that while and loops always evaluate to `nil`.\r\n\r\n#### Blocks ####\r\n\r\nFunctions, cond/if statements, and while loops are all limited to a single\r\nexpression for their bodies. This kind of sucks if you want to do anything\r\nactually interesting with them. Fortunately, it's possible, using blocks, to\r\nmash a bunch of expressions together in a sequence, and return the last computed\r\nresult:\r\n\r\n    let i = do\r\n      puts(\"I'm in a block!\")\r\n      5; 4; 3; 2; 1\r\n    end\r\n    i == 1\r\n\r\nUsing this, it's possible to build actually useful constructs:\r\n\r\n    fn filter(array, predicate): do\r\n      let filtered = []\r\n      for i in array: if pred(i): filtered.append(i)\r\n      filtered\r\n    end\r\n\r\nBlocks have nested scope:\r\n\r\n    do let j = 5 end\r\n    puts(j) // wrong &mdash; j is out of scope\r\n\r\n    let j = 5\r\n    do puts(j) end // fine\r\n\r\n#### Exceptions ####\r\n\r\nLike in C++, exceptions in Vivaldi don't have any special type (in fact at the\r\nmoment there is no builtin exception type; strings are used instead). Otherwise\r\nthey work pretty much as you'd expect:\r\n\r\n    let i = try: except 5\r\n    catch e: e + 1\r\n    i == 6\r\n\r\nAs everywhere else in Vivaldi, the pieces of code following `try` and `catch`\r\nare expressions.\r\n\r\n#### Operators ####\r\n\r\nVivaldi operators, aside from `&&`, `||`, `to` (which is syntax sugar for\r\nRange), and `=` (which isn't actually an operator at all&mdash; it just looks like\r\none), are all just syntax sugar for method calls. Here they are in order of\r\nprecedence (basically C precedence, with the bitwise mistake fixed and `**` and\r\n`to` inserted where appropriate):\r\n\r\n    a[b]     // a.at(b)\r\n    a[b] = c // a.set_at(b, c)\r\n    !a       // a.not()\r\n    -a       // a.negative()\r\n    ~a       // a.negate()\r\n    a ** b   // a.pow(b)\r\n    a * b    // a.times(b)\r\n    a / b    // a.divides(b)\r\n    a % b    // a.modulo(b)\r\n    a + b    // a.add(b)\r\n    a - b    // a.subtract(b)\r\n    a << b   // a.rshift(b)\r\n    a >> b   // a.lshift(b)\r\n    a & b    // a.bitand(b)\r\n    a ^ b    // a.xor(b)\r\n    a | b    // a.bitor(b)\r\n    a to b   // Range(a, b)\r\n    a < b    // a.less(b)\r\n    a > b    // a.greater(b)\r\n    a <= b   // a.less_equals(b)\r\n    a >= b   // a.greater_equals(b)\r\n    a == b   // a.equals(b)\r\n    a != b   // a.unequal(b)\r\n\r\n### Builtins ###\r\n\r\nIn addition to the above types, Vivaldi has a select few builtin functions:\r\n\r\n* `puts(x)`&mdash; as in Ruby, write the passed value plus a newline. Takes only one\r\n  argument.\r\n\r\n* `print(x)`&mdash; identical to `puts`, sans newline.\r\n\r\n* `gets()`&mdash; returns a String containing a single line of user input.\r\n\r\n* `quit()`&mdash; exits the program unconditionally.\r\n\r\nMore to be added eventually.\r\n\r\n### Example ###\r\n\r\n#### FizzBuzz ####\r\n\r\n    for i in 1 to 100: cond\r\n      i % 15 == 0: puts(\"FizzBuzz\"),\r\n      i % 5 == 0:  puts(\"Buzz\"),\r\n      i % 3 == 0:  puts(\"Fizz\"),\r\n      true:        puts(i)\r\n\r\nSee examples folder for more.\r\n\r\n### TODO ###\r\n\r\n* Expand the standard library\r\n\r\n* Add C API\r\n\r\n* Improve performance, especially concerning the call stack\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}